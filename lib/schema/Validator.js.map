{"version":3,"sources":["../../src/schema/Validator.js"],"names":["Validator","environment","value","schema","options","dateFormat","knownTypes","Error","getReferenceAsync","getDecoratorAsync","type","Array","isArray","embedded","itemClasses","name","label","description","version","decorators","assertPropertiesAsync","forEach","decorator","assertDecorator","Promise","all","map","decoratorInformation","validations","validateAsync","test","config","properties","reduce","promise","property","then","resolvedDecorators","resolve","class","propertySchema","propertyValue","propertyValidator","validator","assertIsReady","assertSchema","assertAnyAsync","assertArrayAsync","assertBooleanAsync","assertClassAsync","assertReferenceAsync","assertDateAsync","assertNumberAsync","assertStringAsync"],"mappings":"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","file":"Validator.js","sourcesContent":["export default class Validator {\n    constructor(environment) {\n        this.environment = environment;\n        this.value = null;\n        this.schema = null;\n        this.options = null;\n        this.dateFormat = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n        this.knownTypes = {\n            \"any\": \"any\",\n            \"array\": \"array\",\n            \"boolean\": \"boolean\",\n            \"class\": \"class\",\n            \"date\": \"date\",\n            \"enum\": \"enum\",\n            \"number\": \"number\",\n            \"value\": \"value\",\n            \"reference\": \"reference\",\n            \"string\": \"string\"\n        };\n\n        if (environment == null) {\n            throw new Error(\"Expected an enviroment.\");\n        }\n\n        if (typeof this.environment.getReferenceAsync !== \"function\" ||\n            typeof this.environment.getDecoratorAsync !== \"function\") {\n            throw new Error(\"The environment needs to have both getReferenceAsync and getDecoratorAsync functions.\");\n        }\n    }\n\n    async assertAnyAsync() {\n        if (this.schema.type === \"any\") {\n\n            if (typeof this.value === \"undefined\") {\n                throw new Error(\"Type any cannot be undefined.\");\n            }\n\n        }\n    }\n\n    async assertArrayAsync() {\n        if (this.schema.type === \"array\") {\n\n            if (!Array.isArray(this.value)) {\n                throw new Error(\"Expected an array.\");\n            }\n\n            if (typeof this.schema.embedded !== \"undefined\" && typeof this.schema.embedded !== \"boolean\") {\n                throw new Error(\"Expected the embedded property to be a boolean. \");\n            }\n\n            if (!Array(this.schema.itemClasses)) {\n                throw new Error(\"Expected the itemClasses property to be an array. \");\n            }\n\n        }\n    }\n\n    async assertBooleanAsync() {\n        if (this.schema.type === \"boolean\" && typeof this.value !== \"boolean\") {\n            throw new Error(\"Expected a boolean.\");\n        }\n    }\n\n    async assertClassAsync() {\n        const schema = this.schema;\n        const value = this.value;\n\n        if (schema.type === \"class\") {\n            if (typeof schema.name !== \"string\") {\n                throw new Error(\"Expected the name of a class to be a string.\");\n            }\n\n            if (typeof schema.label !== \"string\") {\n                throw new Error(\"Expected the label of a class to be a string.\");\n            }\n\n            if (typeof schema.description !== \"string\") {\n                throw new Error(\"Expected the description of a class to be a string.\");\n            }\n\n            if (typeof schema.version !== \"string\") {\n                throw new Error(\"Expected the version of a class to be a string.\");\n            }\n\n            if (schema.decorators != null && !Array.isArray(schema.decorators)) {\n                throw new Error(\"Expected the decorators of a class to be an array.\");\n            }\n\n            await this.assertPropertiesAsync();\n\n            if (Array.isArray(schema.decorators)) {\n                schema.decorators.forEach((decorator) => {\n                    this.assertDecorator(decorator);\n                });\n\n                const decorators = await Promise.all(schema.decorators.map((decoratorInformation) => {\n                    return this.environment.getDecoratorAsync(decoratorInformation);\n                }));\n\n                const validations = decorators.map((decorator) => {\n                    if (decorator != null && typeof decorator.validateAsync === \"function\"){\n                        return decorator.validateAsync(schema, value);\n                    }\n                });\n\n                await Promise.all(validations);\n\n            }\n\n        }\n    }\n\n    async assertDateAsync() {\n        if (this.schema.type === \"date\") {\n\n            if (!this.dateFormat.test(this.value)) {\n                throw new Error(\"Expected a date.\");\n            }\n\n        }\n    }\n\n    assertDecorator(decorator) {\n        if (decorator == null) {\n            throw new Error(\"Expected the decorator to be an object.\");\n        }\n\n        if (typeof decorator.name !== \"string\") {\n            throw new Error(\"Expected the decorator's name property to be a string.\");\n        }\n\n        if (decorator.config == null || (decorator.config != null && typeof decorator !== \"object\")) {\n            throw new Error(\"Expected the decorator's config property to be an object.\");\n        }\n    }\n\n    async assertNumberAsync() {\n        if (this.schema.type === \"number\" && typeof this.value !== \"number\") {\n            throw new Error(\"Expected a number.\");\n        }\n    }\n\n    assertIsReady() {\n        if (this.schema == null) {\n            throw new Error(\"Schema and value need to be set before validating.\");\n        }\n    }\n\n    async assertPropertiesAsync() {\n        const schema = this.schema;\n        const value = this.value;\n\n        if (!Array.isArray(schema.properties)) {\n            throw new Error(\"Expected the properties to be an array.\");\n        }\n\n        return schema.properties.reduce((promise, property) => {\n            return promise.then(() => {\n                let resolvedDecorators = Promise.resolve([]);\n\n                if (typeof property.name !== \"string\") {\n                    throw new Error(\"Expected the name of a property to be a string.\");\n                }\n\n                if (typeof property.class !== \"string\" && (property.class != null && typeof property.class === \"object\" && typeof property.class.type !== \"string\")) {\n                    throw new Error(\"Expected the class of a property to be a string, or an object with the type property being a string.\");\n                }\n\n                if (typeof property.label !== \"string\") {\n                    throw new Error(\"Expected the label of a property to be a string.\");\n                }\n\n                if (property.decorators != null && !Array.isArray(property.decorators)) {\n                    throw new Error(`Expected the decorators on the \"${property.name}\" property to be an Array.`);\n                }\n\n                if (Array.isArray(property.decorators)) {\n\n                    property.decorators.forEach((decorator) => {\n                        this.assertDecorator(decorator);\n                    });\n\n                    resolvedDecorators = Promise.all(property.decorators.map((decoratorInformation) => {\n                        return this.environment.getDecoratorAsync(decoratorInformation);\n                    }));\n\n                }\n\n                const propertySchema = property.class;\n                const propertyValue = value[property.name];\n                const propertyValidator = new Validator(this.environment);\n\n                return propertyValidator.validateAsync(propertySchema, propertyValue).then(() => {\n                    return resolvedDecorators;\n                }).then((decorators) => {\n\n                    const validations = decorators.map((decorator) => {\n                        return decorator.validateAsync(propertySchema, propertyValue);\n                    });\n\n                    return Promise.all(validations);\n                });\n\n            });\n\n        }, Promise.resolve());\n    }\n\n    async assertReferenceAsync() {\n        if (this.schema.type === \"reference\") {\n            const schema = await this.environment.getReferenceAsync(this.schema);\n            const validator = new Validator(this.environment);\n            await validator.validateAsync(schema, this.value);\n        }\n    }\n\n    async assertStringAsync() {\n        if (this.schema.type === \"string\" && typeof this.value !== \"string\") {\n            throw new Error(\"Expected a string.\");\n        }\n    }\n\n    assertSchema() {\n        if (!this.knownTypes[this.schema.type]) {\n            throw new Error(`Unknown schema, \"${this.schema.type}\".`);\n        }\n    }\n\n    async validateAsync(schema, value, options) {\n        if (typeof schema === \"string\") {\n            schema = {\n                type: schema\n            }\n        }\n\n        this.value = value;\n        this.schema = schema;\n        this.options = options;\n\n        this.assertIsReady();\n        this.assertSchema();\n\n        await this.assertAnyAsync();\n        await this.assertArrayAsync();\n        await this.assertBooleanAsync();\n        await this.assertClassAsync();\n        await this.assertReferenceAsync();\n        await this.assertDateAsync();\n        await this.assertNumberAsync();\n        await this.assertStringAsync();\n\n        return true;\n    }\n}"]}